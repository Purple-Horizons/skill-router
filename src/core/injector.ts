import { writeFileSync, unlinkSync, existsSync, readFileSync } from 'node:fs';
import { join } from 'node:path';
import type { ScoringResult } from '../types.js';

/**
 * Format matched skills as XML for agent consumption
 * Matches OpenClaw's <available_skills> format
 */
export function formatSkillsAsXml(results: ScoringResult[]): string {
  if (results.length === 0) {
    return '<available_skills>\nNo skills matched the current message.\n</available_skills>';
  }

  const skillEntries = results.map((result) => {
    const { skill, score, matchedKeywords } = result;
    const matchInfo = matchedKeywords.length > 0 ? ` matched="${matchedKeywords.join(', ')}"` : '';
    const scoreInfo = score > 0 ? ` score="${score.toFixed(2)}"` : '';

    return `  <skill name="${skill.name}"${scoreInfo}${matchInfo}>
    <description>${skill.description}</description>
    <location>${skill.location}</location>
  </skill>`;
  });

  return `<available_skills>
${skillEntries.join('\n')}
</available_skills>`;
}

/**
 * Generate context file content with routing instructions
 */
export function generateContextContent(results: ScoringResult[]): string {
  const skillsXml = formatSkillsAsXml(results);
  const skillNames = results.map((r) => r.skill.name);

  let instructions = '';

  if (results.length > 0) {
    const skillPaths = results.map((r) => join(r.skill.location, 'SKILL.md'));
    instructions = `
## Next Steps

Read the SKILL.md file for each matched skill to get detailed instructions:

${skillPaths.map((p) => `- ${p}`).join('\n')}

Then proceed with the user's request using the skill guidance.`;
  } else {
    instructions = `
## Next Steps

No skills matched this message. Proceed with general assistance.`;
  }

  return `# SkillRouter Context

This file was generated by SkillRouter to provide matched skills for the current message.

## Matched Skills

${skillsXml}
${instructions}

---
Generated: ${new Date().toISOString()}
Matched: ${skillNames.join(', ') || 'none'}
`;
}

/**
 * Write context file to disk
 */
export function writeContextFile(results: ScoringResult[], filePath: string): void {
  const content = generateContextContent(results);
  writeFileSync(filePath, content, 'utf-8');
}

/**
 * Read the current context file if it exists
 */
export function readContextFile(filePath: string): string | null {
  try {
    if (!existsSync(filePath)) {
      return null;
    }
    return readFileSync(filePath, 'utf-8');
  } catch {
    return null;
  }
}

/**
 * Clean up context file after use
 */
export function cleanupContextFile(filePath: string): boolean {
  try {
    if (existsSync(filePath)) {
      unlinkSync(filePath);
      return true;
    }
    return false;
  } catch {
    return false;
  }
}
